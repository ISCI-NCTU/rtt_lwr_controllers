&ACCESS RVP
&REL 61
&COMMENT ISIR-CNRS 2016
&PARAM start_pose = {a1 91.88,a2 112.87,a3 -102.22,a4 6.83,a5 55.73,a6 9.67,e1 -6.27}
&PARAM tool_number = 10
&PARAM TEMPLATE = C:\KRC\Roboter\Template\vorgabe
&PARAM fri_rate_ms = 1.0
&PARAM base_number = 0
&PARAM EDITMASK = *
DEF fri_isir_control( )
;FOLD ProgramInfo
; Copyright ISIR-CNRS 2016
; Author: Antoine Hoarau
;ENDFOLD (ProgramInfo)

;FOLD INI
;FOLD BASISTECH INI
GLOBAL INTERRUPT DECL 3 WHEN $STOPMESS==TRUE DO IR_STOPM()
INTERRUPT ON 3
BAS (#INITMOV,0 )
INTERRUPT DECL 4 WHEN $FRI_FRM_BOOL[8]==TRUE DO do_stop2()
INTERRUPT ON 4
INTERRUPT DECL 5 WHEN $FRI_FRM_BOOL[9]==TRUE DO set_vel()
INTERRUPT ON 5
$TIMER_STOP[1] = TRUE
$TIMER[1] = 0
INTERRUPT DECL 6 WHEN $ON_PATH DO write_status()
INTERRUPT OFF 6
INTERRUPT DECL 7 WHEN $fri_frm_bool[2] DO cancel_motion()
INTERRUPT ON 7
INTERRUPT DECL 8 WHEN $fri_frm_bool[2] == FALSE DO continue_motion()
INTERRUPT OFF 8
;ENDFOLD (BASISTECH INI)
;FOLD USER INI
  ;FOLD Initialisation of shared array
  for i=1 to 16
    $fri_to_int[i]=0
    $fri_to_rea[i]=0.0
    $fri_to_bool[i]=false
  endfor
  ;ENDFOLD
;ENDFOLD (USER INI)
;ENDFOLD (INI)

; Script Parameters
tool_number = 10
fri_rate_ms = 1.0
start_pose = {a1 91.88,a2 112.87,a3 -102.22,a4 6.83,a5 55.73,a6 9.67,e1 -6.27}

;FOLD FRI Reset()

if ($FriState <> #OFF) then
  ret=fristop()
  ret=friclose()
endif

$fri_to_int[1] = 0
$fri_to_int[2] = 10
$fri_to_int[3] = tool_number

resetRobotParams()

;BAS(#TOOL,tool_number)
;$STIFFNESS.TOOL = $TOOL
;$STIFFNESS.BASE = $BASE
;$STIFFNESS.COMMIT=TRUE
;ENDFOLD

;Goto Zero Position
PTP XHOME C_PTP
PTP start_pose C_PTP

WAIT SEC 0.1
$TIMER_STOP[1] = FALSE

repeat
  ret=friopen(fri_rate_ms)
  wait sec 0.5
until $FriState == #MON

PTP start_pose

;FOLD Publish BASE pose
$fri_to_rea[1] = $BASE.X
$fri_to_rea[2] = $BASE.Y
$fri_to_rea[3] = $BASE.Z
$fri_to_rea[4] = $BASE.A
$fri_to_rea[5] = $BASE.B
$fri_to_rea[6] = $BASE.C
;ENDFOLD

repeat

  ;FOLD Wait for KRL_LOOP_REQUESTED
  ; Reset Advance run pointer (dafuq ?!)
  $ADVANCE = 3
  INTERRUPT ON 4
  INTERRUPT ON 5
  INTERRUPT ON 7

  wait_for_loop_request()

  ;ENDFOLD

  ;FOLD New Control Mode requested
  if ( $fri_frm_bool[3] ) then

    set_new_control_mode()

  endif
  ;ENDFOLD

  ;FOLD New tool requested
  if( $fri_frm_bool[4] ) then

    set_new_tool()

  endif
  ;ENDFOLD

  ;FOLD New base requested
  if( $fri_frm_bool[5] ) then

    set_new_base()

  endif
  ;ENDFOLD

  ;FOLD Execute PTP Command
  if( $fri_frm_bool[6] ) then

    execute_PTP()

  endif
  ;ENDFOLD

  ;FOLD Execute LIN Command
  if( $fri_frm_bool[7] ) then

    execute_LIN()

  endif
  ;ENDFOLD

  ; This wait is necessary otherwise it will execute
  ; the next set of instructions (!!)
  WAIT SEC 0

  ; Acknowledge all flags (set them to 1)
  for i=1 to 16
    if( (i <> 9) AND (i <> 8) AND (i <> 2) ) then
      $fri_to_bool[i]=$fri_frm_bool[i]
    endif
  endfor

  ; Send response
  WAIT SEC 0

  ; Wait for confirmation (all flags back to 0)
  for i=1 to 16
    if( (i <> 9) AND (i <> 8) AND (i <> 2) ) then
      wait for ($fri_frm_bool[i] == false)
    endif
  endfor

  WAIT SEC 0

until ($fri_frm_int[1] == 3)

;FOLD Ending
PTP CLAMP_AXES($AXIS_ACT)

wait sec 0.2

IF ($FriState==#CMD) THEN
 ret=fristop()
 WAIT FOR ($FriState==#MON)
ENDIF

$fri_to_int[1]=0
WAIT SEC 0.5
ret=friclose()

resetSTIFFNESS()
;move to Home-Position
PTP { a1 0,a2 90,e1 0, a3 0,a4 0,a5 0,a6 0}

END
;ENDFOLD

def wait_for_loop_request()

  for i=1 to 16
    if( (i <> 9) AND (i <> 8) AND (i <> 2) ) then
      $fri_to_bool[i]=false
    endif
  endfor
  if($FriState==#CMD) then
    $fri_to_int[1] = 2
  endif
  if($FriState==#MON) then
    $fri_to_int[1] = 1
  endif

  ;-- Waiting for PC commands --;
  wait for $fri_frm_bool[1]

  use_rel = ($fri_frm_int[6] <> 0)
  input_type = $fri_frm_int[7]

end

def set_new_control_mode()

  $MSG_T.KEY[] = "New Control Mode Requested          "
  $MSG_T.VALID = TRUE

  ; TODO : add a mode 40 Joint torque
  if ( ($fri_frm_int[2] == 10) OR ($fri_frm_int[2] == 20) OR ($fri_frm_int[2] == 30) ) then

    ret=fristop()
    wait for ($fristate==#MON)

    ;Set new Strategy
    $STIFFNESS.STRATEGY = $fri_frm_int[2]
    $STIFFNESS.COMMIT = TRUE

    ;FOLD Screen output
    IF ($stiffness.strategy == 10) THEN
      $MSG_T.KEY[] = "Joint Position Control Mode"
    ELSE
      IF ($stiffness.strategy == 20) THEN
        $MSG_T.KEY[] = "Cartesian Impedance Control Mode"
      ELSE
        IF (($stiffness.strategy == 30) AND (isZeroStiffness($STIFFNESS) == TRUE)) THEN
          $MSG_T.KEY[] = "Joint Torque Control Mode"
        ELSE
          if ($stiffness.strategy == 30) then
            $MSG_T.KEY[] = "Joint Impedance Control Mode"
          else
            $MSG_T.KEY[] = "ERROR: Wrong Control Strategy"
          endif
        ENDIF
      ENDIF
    ENDIF
    $MSG_T.VALID = TRUE

    ;ENDFOLD (Screen output)

    PTP CLAMP_AXES($AXIS_ACT)
    ret=fristart(1.0)
    wait sec 0.2

  endif

end

def set_new_base()

  $MSG_T.KEY[] = "New Base Requested                  "
  $MSG_T.VALID = TRUE

  if( $fri_frm_int[4] >= 0 ) then
    BAS(#BASE,$fri_frm_int[4])
    $STIFFNESS.TOOL = $TOOL
    $STIFFNESS.BASE = $BASE
    $STIFFNESS.COMMIT=TRUE
    $fri_to_int[4] = $fri_frm_int[4]
    ;FOLD Publish BASE pose
    $fri_to_rea[1] = $BASE.X
    $fri_to_rea[2] = $BASE.Y
    $fri_to_rea[3] = $BASE.Z
    $fri_to_rea[4] = $BASE.A
    $fri_to_rea[5] = $BASE.B
    $fri_to_rea[6] = $BASE.C
    ;ENDFOLD
  endif

end

def set_new_tool()

  $MSG_T.KEY[] = "New Tool Requested                  "
  $MSG_T.VALID = TRUE

  if( $fri_frm_int[3] >= 0 ) then
    BAS(#TOOL,$fri_frm_int[3])
    $STIFFNESS.TOOL = $TOOL
    $STIFFNESS.BASE = $BASE
    $STIFFNESS.COMMIT=TRUE
    $fri_to_int[3] = $fri_frm_int[3]
  endif

end

def wait_for_acknowledgment()
  ; This wait is necessary otherwise it will execute
  ; the next set of instructions (!!)
  WAIT SEC 0

  ; Acknowledge all flags (set them to 1)
  for i=1 to 16
    if( (i <> 9) AND (i <> 8) AND (i <> 2) ) then
      $fri_to_bool[i]=$fri_frm_bool[i]
    endif
  endfor

  ; Send response
  WAIT SEC 0

  ; Wait for confirmation (all flags back to 0)
  for i=1 to 16
    if( (i <> 9) AND (i <> 8) AND (i <> 2) ) then
      wait for ($fri_frm_bool[i] == false)
    endif
  endfor

  WAIT SEC 0
end

DEFFCT BOOL isZeroStiffness(s:IN)
  DECL STIFFNESS s
  if( (s.axisstiffness.a1 == 0) AND (s.axisstiffness.a2 == 0) AND (s.axisstiffness.e1 == 0) AND (s.axisstiffness.a3 == 0) AND (s.axisstiffness.a4 == 0) AND (s.axisstiffness.a5 == 0) AND (s.axisstiffness.a6 == 0)) then
    return true
  endif
  return false
ENDFCT

DEFFCT E6AXIS BuildJntCmdFromFRI(use_relative:IN)
  DECL E6AXIS JOINT_OUT
  BOOL use_relative

  BAS(#PTP_PARAMS,$fri_frm_rea[7])

  if(use_relative) then
    JOINT_OUT = {A1 0.0, A2 0.0, E1 0.0, A3 0.0, A4 0.0, A5 0.0, A6 0.0}
  else
    JOINT_OUT = CLAMP_AXES($AXIS_ACT)
  endif

  if( $fri_frm_bool[10] ) then
    JOINT_OUT.A1 = $fri_frm_rea[10]
  endif

  if( $fri_frm_bool[11] ) then
    JOINT_OUT.A2 = $fri_frm_rea[11]
  endif

  if( $fri_frm_bool[12] ) then
    JOINT_OUT.E1 = $fri_frm_rea[12]
  endif

  if( $fri_frm_bool[13] ) then
    JOINT_OUT.A3 = $fri_frm_rea[13]
  endif

  if( $fri_frm_bool[14] ) then
    JOINT_OUT.A4 = $fri_frm_rea[14]
  endif

  if( $fri_frm_bool[15] ) then
    JOINT_OUT.A5 = $fri_frm_rea[15]
  endif

  if( $fri_frm_bool[16] ) then
    JOINT_OUT.A6 = $fri_frm_rea[16]
  endif

  return CLAMP_AXES(JOINT_OUT)
ENDFCT

DEFFCT POS BuildCartCmdFromFRI(use_relative:IN)
  DECL POS CART_OUT
  BOOL use_relative

  BAS(#CP_PARAMS,$fri_frm_rea[7])

  if(use_relative) then
    CART_OUT = {x 0.0, y 0.0, z 0.0, a 0.0, b 0.0, c 0.0}
  else
    CART_OUT = $POS_ACT
  endif

  if( $fri_frm_bool[10] ) then
    CART_OUT.X = $fri_frm_rea[1]
  endif

  if( $fri_frm_bool[11] ) then
    CART_OUT.Y = $fri_frm_rea[2]
  endif

  if( $fri_frm_bool[12] ) then
    CART_OUT.Z = $fri_frm_rea[3]
  endif

  if( $fri_frm_bool[13] ) then
    CART_OUT.A = $fri_frm_rea[4]
  endif

  if( $fri_frm_bool[14] ) then
    CART_OUT.B = $fri_frm_rea[5]
  endif

  if( $fri_frm_bool[15] ) then
    CART_OUT.C = $fri_frm_rea[6]
  endif

  ;CART_OUT.E1 = 0.0
  ;CART_OUT.S = 'B001'
  ;CART_OUT.T = 'B100100'
  ;CART_OUT.E1 = $POS_ACT.E1
  ;STRING_OFFSET = 0
  ;SWRITE($MSG_T.KEY[], STATE, STRING_OFFSET, "POS(x %.2f, y %.2f, z %.2f)", CART_OUT.X,CART_OUT.Y,CART_OUT.Z)
  ;$MSG_T.VALID = TRUE
  ;wait for $MSG_T.VALID == FALSE
  ;STRING_OFFSET = 0
  ;SWRITE($MSG_T.KEY[], STATE, STRING_OFFSET, "POS(A %.2f, B %.2f, C %.2f)",CART_OUT.A,CART_OUT.B,CART_OUT.C)
  ;$MSG_T.VALID = TRUE
  ;wait for $MSG_T.VALID == FALSE
  return CART_OUT
ENDFCT

def do_stop2()

$fri_to_bool[8] = true
$msg_t.key[] = "stop2 requested                         "
$msg_t.valid = true
brake
$msg_t.key[] = "waiting for fri_bool[8] to resume       "
$msg_t.valid = true
wait for $fri_frm_bool[8] == false

end

def set_vel( )

if( ($fri_frm_rea[9] >= 0) or ($fri_frm_rea[9] <= 100)) then

  ;BAS (#VEL_PTP, $fri_frm_rea[9])
  $OV_PRO = $fri_frm_rea[9]
  $MSG_T.KEY[] = "Setting new velocity                  "
  $MSG_T.VALID = true
  $fri_to_bool[9] = true
  wait for ($fri_frm_bool[9] == false)
  $fri_to_bool[9] = false
endif

end

DEFFCT REAL CALC_COMPL(start_v:in,end_v:in,current_v:in)
  REAL start_v
  REAL end_v
  REAL current_v
  DECL REAL tmp
  DECL REAL d

  d = end_v - start_v

  if(d == 0.0) then
    return 1.0
  endif

  if(d < 0.0) then
    start_v = abs(start_v)
    end_v = abs(end_v)
    current_v = abs(current_v)
  endif

  return (current_v - start_v ) / (end_v - start_v)
ENDFCT

def execute_PTP()

  if( use_rel ) then
    $MSG_T.KEY[] = "New PTP_REL Command               "
  else
    $MSG_T.KEY[] = "New PTP Command                   "
  endif

  $MSG_T.VALID = TRUE

  switch input_type
  case 0

    if(use_rel) then
      PTP_REL BuildJntCmdFromFRI(true)
      $ADVANCE = 0
    else
      PTP BuildJntCmdFromFRI(false)
      $ADVANCE = 0

    endif

  case 1

    if(use_rel) then
      PTP_REL BuildCartCmdFromFRI(true)
      $ADVANCE = 0
    else
      PTP BuildCartCmdFromFRI(false)
      $ADVANCE = 0
    endif

  endswitch

end

def execute_LIN()
  if( use_rel ) then
    $MSG_T.KEY[] = "New LIN_REL Command               "
  else
    $MSG_T.KEY[] = "New LIN Command                   "
  endif

  $MSG_T.VALID = TRUE

  if(use_rel) then
    LIN_REL BuildCartCmdFromFRI(true)
    $ADVANCE = 0
  else
    LIN BuildCartCmdFromFRI(false)
    $ADVANCE = 0
  endif
end


def continue_motion()

  $MSG_T.KEY[] = "Continue Motion                  "
  $MSG_T.VALID = true
  continue
  $fri_to_bool[2] = false
  INTERRUPT OFF 8

end

def cancel_motion()

  brake
  $MSG_T.KEY[] = "Cancelling Motion                  "
  $MSG_T.VALID = true
  INTERRUPT ON 8
  $fri_to_bool[2] = true
  wait sec 0
  resume

end


def write_status()
  ;$fri_to_rea[1] = $BASE.X
  ;$fri_to_rea[2] = $BASE.Y
  ;$fri_to_rea[3] = $BASE.Z
  ;$fri_to_rea[4] = $BASE.A
  ;$fri_to_rea[5] = $BASE.B
  ;$fri_to_rea[6] = $BASE.C

  ;$fri_to_rea[7]  = CALC_COMPL($POS_BACK.X,  $POS_FOR.X,$POS_ACT.X)
  ;$fri_to_rea[8]  = CALC_COMPL($POS_BACK.Y,  $POS_FOR.Y,$POS_ACT.Y)
  ;$fri_to_rea[9]  = CALC_COMPL($POS_BACK.Z,  $POS_FOR.Z,$POS_ACT.Z)
  ;
  ;$fri_to_rea[10] = CALC_COMPL($AXIS_BACK.A1 ,$AXIS_FOR.A1,$AXIS_ACT.A1)
  ;$fri_to_rea[11] = CALC_COMPL($AXIS_BACK.A2 ,$AXIS_FOR.A2,$AXIS_ACT.A2)
  ;$fri_to_rea[12] = CALC_COMPL($AXIS_BACK.E1 ,$AXIS_FOR.E1,$AXIS_ACT.E1)
  ;$fri_to_rea[13] = CALC_COMPL($AXIS_BACK.A3 ,$AXIS_FOR.A3,$AXIS_ACT.A3)
  ;$fri_to_rea[14] = CALC_COMPL($AXIS_BACK.A4 ,$AXIS_FOR.A4,$AXIS_ACT.A4)
  ;$fri_to_rea[15] = CALC_COMPL($AXIS_BACK.A5 ,$AXIS_FOR.A5,$AXIS_ACT.A5)
  ;$fri_to_rea[16] = CALC_COMPL($AXIS_BACK.A6 ,$AXIS_FOR.A6,$AXIS_ACT.A6)
  ;
  ;INTERRUPT ON 6
end

DEF resetRobotParams( )

 ;Control Strategy
 $STIFFNESS.STRATEGY = 10

 ;Frame for Cartesian Stiffness mode #TOOL or #BASE
 $STIFFNESS.FRAMETYPE = #BASE

 ;Cartesian Spring Stiffness [0.01, 5000] N/m
 $STIFFNESS.CPSTIFFNESS = {X 2000, Y 2000, Z 2000, A 200, B 200, C 200}

 ;Cartesian Spring Damping [0.1, 1.0] N*s/m
 $STIFFNESS.CPDAMPING = {X 0.7, Y 0.7, Z 0.7, A 0.7, B 0.7, C 0.7}

 ;Axis specific spring stiffness [0.01, 2000] Nm/rad
 $STIFFNESS.AXISSTIFFNESS = {A1 1000.0, A2 1000.0, A3 1000.0, A4 1000.0, A5 1000.0, A6 1000.0, E1 1000.0}

 ;$STIFFNESS.AXISSTIFFNESS = {A1 100, A2 100, A3 100, A4 100, A5 100, A6 100, E1 100}
 ;Axis specific spring damping [0.1, 1.0] Nm*s/rad
 $STIFFNESS.AXISDAMPING = {A1 0.7, A2 0.7, A3 0.7, A4 0.7, A5 0.7, A6 0.7, E1 0.7}

 ;Limitation of the cartesian deviation from path [0.1, 100] mm
 $STIFFNESS.CPMAXDELTA = {X 100, Y 100, Z 100, A 10, B 10, C 10}

 ;Limitation of the Cartesian force at the Tool Center Point Recommanded max: 150N
 $STIFFNESS.MAXFORCE = {X 150.0, Y 150.0, Z 150.0, A 20.0, B 20.0, C 20.0}

 ;Limitation of the axis specific deviation in degree
 $STIFFNESS.AXISMAXDELTA = {A1 90.0, A2 90.0, A3 90.0, A4 90.0, A5 90.0, A6 90.0, E1 90.0}

 ;Limitation of the axis specific max torque
 $STIFFNESS.AXISMAXDELTATRQ = {A1 20.0, A2 20.0, A3 20.0, A4 20.0, A5 20.0, A6 20.0, E1 20.0}

 $STIFFNESS.COMMIT=TRUE
END

DEFFCT E6AXIS TOUCH_AXIS(ax:IN)
 E6AXIS ax
 DECL E6AXIS an
 an = CLAMP_AXES(ax)
  if an.A6 <0 then
   an.A6 = an.A6 + 0.01
  else
   an.A6 = an.A6 - 0.01
  endif
 return an
ENDFCT

DEFFCT E6AXIS CLAMP_AXES(ax:IN)
 E6AXIS ax

 DECL E6AXIS an

 an.A1 = CLAMP(ax.A1, -169., 169.)
 an.A2 = CLAMP(ax.A2,  -29., 209.)

 an.E1 = CLAMP(ax.E1, -169., 169.)
 an.A3 = CLAMP(ax.A3, -119., 119.)
 an.A4 = CLAMP(ax.A4, -169., 169.)
 an.A5 = CLAMP(ax.A5, -119., 119.)
 an.A6 = CLAMP(ax.A6, -169., 169.)

 RETURN an
ENDFCT

DEFFCT REAL CLAMP(v:IN, minval:IN, maxval:IN)
 REAL v, minval, maxval
 DECL REAL r

 r = v

 IF v > maxval THEN
  r = maxval
 ENDIF

 IF v < minval THEN
  r = minval
 ENDIF

 RETURN r
ENDFCT
